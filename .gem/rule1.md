# rule1 개발 규칙 (최적화)

## 1. 목적과 적용 범위

- 이 문서는 `spring-restapi` 코드 수정 시 반드시 지켜야 하는 공통 규칙이다.
- 구현 전/중/후 체크리스트로 사용한다.

## 2. 작업 시작 규칙

1. 작업 시작 전에 수정 대상 파일(변경 범위)을 먼저 선언한다.
2. 선언 범위를 벗어난 수정이 필요하면 사유를 남기고 진행한다.
3. 기능 구현 전, 기존 동일 기능이 있는지 먼저 확인한다.

## 3. 설계 및 계층 규칙

1. Controller는 라우팅, 요청/응답 변환만 담당한다.
2. Service는 비즈니스 로직과 트랜잭션 경계를 담당한다.
3. Repository는 데이터 접근과 쿼리만 담당한다.
4. Controller에서 Repository를 직접 호출하지 않는다.
5. API 경로는 REST 규칙을 따른다. (예: `/api/users/{id}`)
6. 인증/응답 스타일은 `AuthController` 패턴과 일관되게 유지한다.

## 4. DTO 및 응답 규칙

1. DTO 클래스는 기본적으로 `@Data`를 사용한다.
2. Request DTO와 Response DTO를 분리한다.
3. API 응답에 JPA 엔티티를 직접 반환하지 않는다.
4. 응답은 반드시 Response DTO로 변환해서 반환한다.
5. 응답 포맷은 공통 규격(`Resp.ok`, `Resp.fail`)을 따른다.

## 5. 보안 및 예외 처리 규칙

1. CORS 처리는 `SecurityConfig`에서 단일하게 관리한다.
2. CORS를 Security로 통합했으면 `FilterConfig`, `CorsFilter` 등 중복 설정은 제거하거나 미사용 상태를 명확히 표시한다.
3. `SecurityConfig.requestMatchers` 변경 시 변경 이유와 영향 API를 주석 또는 작업 로그에 남긴다.
4. 비즈니스 예외는 Service 계층에서 커스텀 예외(`Exception400/401/403/404/500`)로 처리한다.
5. Controller에서 `try-catch`로 예외를 삼키지 않고 전역 예외 처리기로 전달한다.

## 6. 데이터 접근 및 성능 규칙

1. 조회 Service 메서드는 `@Transactional(readOnly = true)`를 사용한다.
2. 쓰기(생성/수정/삭제) 로직에는 `readOnly`를 사용하지 않는다.
3. LAZY 연관관계 조회 시 N+1 문제를 항상 점검한다.
4. 필요하면 Repository에 `fetch join` 또는 최적화 쿼리 메서드를 추가한다.
5. 목록/상세 조회는 응답에 필요한 필드 중심으로 설계한다.
6. 쿼리 추가/변경 시 N+1 위험 여부와 최적화 여부를 주석 또는 작업 로그에 남긴다.

## 7. 코드 스타일 및 정리 규칙

1. Stream API는 메서드 레퍼런스(`::`)보다 람다를 우선 사용한다.
2. 추가/변경/삭제한 소스코드에는 변경 이유 주석을 남긴다.
3. 기존 코드가 대체되었으면 불필요한 코드는 제거한다.
4. 동일 기능 코드의 중복 구현을 금지한다.

## 8. 인코딩 규칙

1. `.java` 파일은 `UTF-8 without BOM`을 사용한다.
2. `.md` 파일은 `UTF-8`로 통일한다.
3. 한글 깨짐이 발생하면 기능 작업보다 인코딩 복구를 우선한다.

## 9. 완료 검증 규칙

1. 구현 후 최소 1회 검증(컴파일 또는 실행 확인)을 수행한다.
2. 규칙 위반이 보이면 기능 추가보다 규칙 위반 수정이 우선이다.
3. 최종 보고에 적용한 규칙 항목을 간단히 명시한다.